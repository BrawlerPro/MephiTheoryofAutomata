Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> program
Rule 1     program -> stmt_list
Rule 2     stmt_list -> <empty>
Rule 3     stmt_list -> stmt_list stmt
Rule 4     stmt -> var_decl NEWLINE
Rule 5     stmt -> const_decl NEWLINE
Rule 6     stmt -> map_decl NEWLINE
Rule 7     stmt -> proc_decl NEWLINE
Rule 8     stmt -> assignment NEWLINE
Rule 9     stmt -> incdec NEWLINE
Rule 10    stmt -> if_stmt NEWLINE
Rule 11    stmt -> while_stmt NEWLINE
Rule 12    stmt -> proc_call NEWLINE
Rule 13    stmt -> robot_op NEWLINE
Rule 14    stmt -> map_op NEWLINE
Rule 15    stmt -> print_stmt NEWLINE
Rule 16    stmt -> NEWLINE
Rule 17    var_decl -> KW_INT IDENTIFIER OP_ASSIGN expr
Rule 18    var_decl -> KW_BOOLEAN IDENTIFIER OP_ASSIGN expr
Rule 19    const_decl -> KW_CINT IDENTIFIER OP_ASSIGN expr
Rule 20    const_decl -> KW_CBOOLEAN IDENTIFIER OP_ASSIGN expr
Rule 21    map_decl -> KW_MAP IDENTIFIER
Rule 22    proc_decl -> KW_PROC IDENTIFIER param_list_opt block
Rule 23    param_list_opt -> param_list
Rule 24    param_list_opt -> empty
Rule 25    param_list -> IDENTIFIER
Rule 26    param_list -> param_list IDENTIFIER
Rule 27    block -> LPAREN opt_nl stmt_list opt_nl RPAREN
Rule 28    opt_nl -> opt_nl NEWLINE
Rule 29    opt_nl -> empty
Rule 30    assignment -> IDENTIFIER OP_ASSIGN expr
Rule 31    incdec -> OP_INC expr expr
Rule 32    incdec -> OP_DEC expr expr
Rule 33    if_stmt -> KW_IF expr block else_opt
Rule 34    else_opt -> KW_ELSE block
Rule 35    else_opt -> empty
Rule 36    while_stmt -> KW_WHILE expr KW_DO block
Rule 37    proc_call -> IDENTIFIER param_list_opt
Rule 38    robot_op -> OP_STEP IDENTIFIER
Rule 39    robot_op -> OP_BACK
Rule 40    robot_op -> OP_RIGHT
Rule 41    robot_op -> OP_LEFT
Rule 42    robot_op -> OP_LOOK
Rule 43    map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
Rule 44    map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
Rule 45    map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
Rule 46    map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
Rule 47    print_stmt -> KW_PRINT expr
Rule 48    expr -> arith_expr
Rule 49    expr -> logic_expr
Rule 50    expr -> robot_op
Rule 51    expr -> proc_call
Rule 52    arith_expr -> arith_expr + arith_expr
Rule 53    arith_expr -> arith_expr - arith_expr
Rule 54    arith_expr -> arith_expr OP_INC arith_expr
Rule 55    arith_expr -> arith_expr OP_DEC arith_expr
Rule 56    arith_expr -> term
Rule 57    term -> INT_LITERAL
Rule 58    term -> IDENTIFIER
Rule 59    term -> proc_call
Rule 60    term -> OP_LOOK
Rule 61    logic_expr -> TRUE
Rule 62    logic_expr -> FALSE
Rule 63    logic_expr -> OP_NOT LPAREN logic_expr RPAREN
Rule 64    logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN
Rule 65    logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN
Rule 66    logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN
Rule 67    logic_expr -> logic_expr OP_OR logic_expr
Rule 68    empty -> <empty>

Terminals, with rules where they appear

+                    : 52
-                    : 53
COMMA                : 43 43 43 44 44 44 45 45 45 46 46 46 64 65 66
FALSE                : 62
IDENTIFIER           : 17 18 19 20 21 22 25 26 30 37 38 43 43 44 44 45 45 46 46 58
INT_LITERAL          : 57
KW_BOOLEAN           : 18
KW_CBOOLEAN          : 20
KW_CINT              : 19
KW_DO                : 36
KW_ELSE              : 34
KW_IF                : 33
KW_INT               : 17
KW_MAP               : 21
KW_PRINT             : 47
KW_PROC              : 22
KW_WHILE             : 36
LPAREN               : 27 43 44 45 46 63 64 65 66
MAP_BAR              : 43
MAP_CLR              : 46
MAP_EMP              : 44
MAP_SET              : 45
NEWLINE              : 4 5 6 7 8 9 10 11 12 13 14 15 16 28
OP_ASSIGN            : 17 18 19 20 30
OP_BACK              : 39
OP_DEC               : 32 55
OP_EQ                : 66
OP_GT                : 64
OP_INC               : 31 54
OP_LEFT              : 41
OP_LOOK              : 42 60
OP_LT                : 65
OP_NOT               : 63
OP_OR                : 67
OP_RIGHT             : 40
OP_STEP              : 38
RPAREN               : 27 43 44 45 46 63 64 65 66
TRUE                 : 61
error                : 

Nonterminals, with rules where they appear

arith_expr           : 43 43 44 44 45 45 46 46 48 52 52 53 53 54 54 55 55
assignment           : 8
block                : 22 33 34 36
const_decl           : 5
else_opt             : 33
empty                : 24 29 35
expr                 : 17 18 19 20 30 31 31 32 32 33 36 47 64 64 65 65 66 66
if_stmt              : 10
incdec               : 9
logic_expr           : 49 63 67 67
map_decl             : 6
map_op               : 14
opt_nl               : 27 27 28
param_list           : 23 26
param_list_opt       : 22 37
print_stmt           : 15
proc_call            : 12 51 59
proc_decl            : 7
program              : 0
robot_op             : 13 50
stmt                 : 3
stmt_list            : 1 3 27
term                 : 56
var_decl             : 4
while_stmt           : 11

Parsing method: LALR

state 0

    (0) S' -> . program
    (1) program -> . stmt_list
    (2) stmt_list -> .
    (3) stmt_list -> . stmt_list stmt

    NEWLINE         reduce using rule 2 (stmt_list -> .)
    KW_INT          reduce using rule 2 (stmt_list -> .)
    KW_BOOLEAN      reduce using rule 2 (stmt_list -> .)
    KW_CINT         reduce using rule 2 (stmt_list -> .)
    KW_CBOOLEAN     reduce using rule 2 (stmt_list -> .)
    KW_MAP          reduce using rule 2 (stmt_list -> .)
    KW_PROC         reduce using rule 2 (stmt_list -> .)
    IDENTIFIER      reduce using rule 2 (stmt_list -> .)
    OP_INC          reduce using rule 2 (stmt_list -> .)
    OP_DEC          reduce using rule 2 (stmt_list -> .)
    KW_IF           reduce using rule 2 (stmt_list -> .)
    KW_WHILE        reduce using rule 2 (stmt_list -> .)
    OP_STEP         reduce using rule 2 (stmt_list -> .)
    OP_BACK         reduce using rule 2 (stmt_list -> .)
    OP_RIGHT        reduce using rule 2 (stmt_list -> .)
    OP_LEFT         reduce using rule 2 (stmt_list -> .)
    OP_LOOK         reduce using rule 2 (stmt_list -> .)
    MAP_BAR         reduce using rule 2 (stmt_list -> .)
    MAP_EMP         reduce using rule 2 (stmt_list -> .)
    MAP_SET         reduce using rule 2 (stmt_list -> .)
    MAP_CLR         reduce using rule 2 (stmt_list -> .)
    KW_PRINT        reduce using rule 2 (stmt_list -> .)
    $end            reduce using rule 2 (stmt_list -> .)

    program                        shift and go to state 1
    stmt_list                      shift and go to state 2

state 1

    (0) S' -> program .



state 2

    (1) program -> stmt_list .
    (3) stmt_list -> stmt_list . stmt
    (4) stmt -> . var_decl NEWLINE
    (5) stmt -> . const_decl NEWLINE
    (6) stmt -> . map_decl NEWLINE
    (7) stmt -> . proc_decl NEWLINE
    (8) stmt -> . assignment NEWLINE
    (9) stmt -> . incdec NEWLINE
    (10) stmt -> . if_stmt NEWLINE
    (11) stmt -> . while_stmt NEWLINE
    (12) stmt -> . proc_call NEWLINE
    (13) stmt -> . robot_op NEWLINE
    (14) stmt -> . map_op NEWLINE
    (15) stmt -> . print_stmt NEWLINE
    (16) stmt -> . NEWLINE
    (17) var_decl -> . KW_INT IDENTIFIER OP_ASSIGN expr
    (18) var_decl -> . KW_BOOLEAN IDENTIFIER OP_ASSIGN expr
    (19) const_decl -> . KW_CINT IDENTIFIER OP_ASSIGN expr
    (20) const_decl -> . KW_CBOOLEAN IDENTIFIER OP_ASSIGN expr
    (21) map_decl -> . KW_MAP IDENTIFIER
    (22) proc_decl -> . KW_PROC IDENTIFIER param_list_opt block
    (30) assignment -> . IDENTIFIER OP_ASSIGN expr
    (31) incdec -> . OP_INC expr expr
    (32) incdec -> . OP_DEC expr expr
    (33) if_stmt -> . KW_IF expr block else_opt
    (36) while_stmt -> . KW_WHILE expr KW_DO block
    (37) proc_call -> . IDENTIFIER param_list_opt
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (43) map_op -> . MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (44) map_op -> . MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (45) map_op -> . MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (46) map_op -> . MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (47) print_stmt -> . KW_PRINT expr

    $end            reduce using rule 1 (program -> stmt_list .)
    NEWLINE         shift and go to state 5
    KW_INT          shift and go to state 17
    KW_BOOLEAN      shift and go to state 19
    KW_CINT         shift and go to state 20
    KW_CBOOLEAN     shift and go to state 21
    KW_MAP          shift and go to state 22
    KW_PROC         shift and go to state 23
    IDENTIFIER      shift and go to state 18
    OP_INC          shift and go to state 24
    OP_DEC          shift and go to state 25
    KW_IF           shift and go to state 26
    KW_WHILE        shift and go to state 27
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 32
    MAP_BAR         shift and go to state 33
    MAP_EMP         shift and go to state 34
    MAP_SET         shift and go to state 35
    MAP_CLR         shift and go to state 36
    KW_PRINT        shift and go to state 37

    stmt                           shift and go to state 3
    var_decl                       shift and go to state 4
    const_decl                     shift and go to state 6
    map_decl                       shift and go to state 7
    proc_decl                      shift and go to state 8
    assignment                     shift and go to state 9
    incdec                         shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    proc_call                      shift and go to state 13
    robot_op                       shift and go to state 14
    map_op                         shift and go to state 15
    print_stmt                     shift and go to state 16

state 3

    (3) stmt_list -> stmt_list stmt .

    NEWLINE         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_INT          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_BOOLEAN      reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_CINT         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_CBOOLEAN     reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_MAP          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_PROC         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    IDENTIFIER      reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_INC          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_DEC          reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_IF           reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_WHILE        reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_STEP         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_BACK         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_RIGHT        reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_LEFT         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    OP_LOOK         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    MAP_BAR         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    MAP_EMP         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    MAP_SET         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    MAP_CLR         reduce using rule 3 (stmt_list -> stmt_list stmt .)
    KW_PRINT        reduce using rule 3 (stmt_list -> stmt_list stmt .)
    $end            reduce using rule 3 (stmt_list -> stmt_list stmt .)
    RPAREN          reduce using rule 3 (stmt_list -> stmt_list stmt .)


state 4

    (4) stmt -> var_decl . NEWLINE

    NEWLINE         shift and go to state 38


state 5

    (16) stmt -> NEWLINE .

    NEWLINE         reduce using rule 16 (stmt -> NEWLINE .)
    KW_INT          reduce using rule 16 (stmt -> NEWLINE .)
    KW_BOOLEAN      reduce using rule 16 (stmt -> NEWLINE .)
    KW_CINT         reduce using rule 16 (stmt -> NEWLINE .)
    KW_CBOOLEAN     reduce using rule 16 (stmt -> NEWLINE .)
    KW_MAP          reduce using rule 16 (stmt -> NEWLINE .)
    KW_PROC         reduce using rule 16 (stmt -> NEWLINE .)
    IDENTIFIER      reduce using rule 16 (stmt -> NEWLINE .)
    OP_INC          reduce using rule 16 (stmt -> NEWLINE .)
    OP_DEC          reduce using rule 16 (stmt -> NEWLINE .)
    KW_IF           reduce using rule 16 (stmt -> NEWLINE .)
    KW_WHILE        reduce using rule 16 (stmt -> NEWLINE .)
    OP_STEP         reduce using rule 16 (stmt -> NEWLINE .)
    OP_BACK         reduce using rule 16 (stmt -> NEWLINE .)
    OP_RIGHT        reduce using rule 16 (stmt -> NEWLINE .)
    OP_LEFT         reduce using rule 16 (stmt -> NEWLINE .)
    OP_LOOK         reduce using rule 16 (stmt -> NEWLINE .)
    MAP_BAR         reduce using rule 16 (stmt -> NEWLINE .)
    MAP_EMP         reduce using rule 16 (stmt -> NEWLINE .)
    MAP_SET         reduce using rule 16 (stmt -> NEWLINE .)
    MAP_CLR         reduce using rule 16 (stmt -> NEWLINE .)
    KW_PRINT        reduce using rule 16 (stmt -> NEWLINE .)
    $end            reduce using rule 16 (stmt -> NEWLINE .)
    RPAREN          reduce using rule 16 (stmt -> NEWLINE .)


state 6

    (5) stmt -> const_decl . NEWLINE

    NEWLINE         shift and go to state 39


state 7

    (6) stmt -> map_decl . NEWLINE

    NEWLINE         shift and go to state 40


state 8

    (7) stmt -> proc_decl . NEWLINE

    NEWLINE         shift and go to state 41


state 9

    (8) stmt -> assignment . NEWLINE

    NEWLINE         shift and go to state 42


state 10

    (9) stmt -> incdec . NEWLINE

    NEWLINE         shift and go to state 43


state 11

    (10) stmt -> if_stmt . NEWLINE

    NEWLINE         shift and go to state 44


state 12

    (11) stmt -> while_stmt . NEWLINE

    NEWLINE         shift and go to state 45


state 13

    (12) stmt -> proc_call . NEWLINE

    NEWLINE         shift and go to state 46


state 14

    (13) stmt -> robot_op . NEWLINE

    NEWLINE         shift and go to state 47


state 15

    (14) stmt -> map_op . NEWLINE

    NEWLINE         shift and go to state 48


state 16

    (15) stmt -> print_stmt . NEWLINE

    NEWLINE         shift and go to state 49


state 17

    (17) var_decl -> KW_INT . IDENTIFIER OP_ASSIGN expr

    IDENTIFIER      shift and go to state 50


state 18

    (30) assignment -> IDENTIFIER . OP_ASSIGN expr
    (37) proc_call -> IDENTIFIER . param_list_opt
    (23) param_list_opt -> . param_list
    (24) param_list_opt -> . empty
    (25) param_list -> . IDENTIFIER
    (26) param_list -> . param_list IDENTIFIER
    (68) empty -> .

    OP_ASSIGN       shift and go to state 52
    IDENTIFIER      shift and go to state 51
    NEWLINE         reduce using rule 68 (empty -> .)

    param_list_opt                 shift and go to state 53
    param_list                     shift and go to state 54
    empty                          shift and go to state 55

state 19

    (18) var_decl -> KW_BOOLEAN . IDENTIFIER OP_ASSIGN expr

    IDENTIFIER      shift and go to state 56


state 20

    (19) const_decl -> KW_CINT . IDENTIFIER OP_ASSIGN expr

    IDENTIFIER      shift and go to state 57


state 21

    (20) const_decl -> KW_CBOOLEAN . IDENTIFIER OP_ASSIGN expr

    IDENTIFIER      shift and go to state 58


state 22

    (21) map_decl -> KW_MAP . IDENTIFIER

    IDENTIFIER      shift and go to state 59


state 23

    (22) proc_decl -> KW_PROC . IDENTIFIER param_list_opt block

    IDENTIFIER      shift and go to state 60


state 24

    (31) incdec -> OP_INC . expr expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 61
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 25

    (32) incdec -> OP_DEC . expr expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 76
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 26

    (33) if_stmt -> KW_IF . expr block else_opt
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 77
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 27

    (36) while_stmt -> KW_WHILE . expr KW_DO block
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 78
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 28

    (38) robot_op -> OP_STEP . IDENTIFIER

    IDENTIFIER      shift and go to state 79


state 29

    (39) robot_op -> OP_BACK .

    NEWLINE         reduce using rule 39 (robot_op -> OP_BACK .)
    TRUE            reduce using rule 39 (robot_op -> OP_BACK .)
    FALSE           reduce using rule 39 (robot_op -> OP_BACK .)
    OP_NOT          reduce using rule 39 (robot_op -> OP_BACK .)
    OP_GT           reduce using rule 39 (robot_op -> OP_BACK .)
    OP_LT           reduce using rule 39 (robot_op -> OP_BACK .)
    OP_EQ           reduce using rule 39 (robot_op -> OP_BACK .)
    OP_STEP         reduce using rule 39 (robot_op -> OP_BACK .)
    OP_BACK         reduce using rule 39 (robot_op -> OP_BACK .)
    OP_RIGHT        reduce using rule 39 (robot_op -> OP_BACK .)
    OP_LEFT         reduce using rule 39 (robot_op -> OP_BACK .)
    OP_LOOK         reduce using rule 39 (robot_op -> OP_BACK .)
    IDENTIFIER      reduce using rule 39 (robot_op -> OP_BACK .)
    INT_LITERAL     reduce using rule 39 (robot_op -> OP_BACK .)
    LPAREN          reduce using rule 39 (robot_op -> OP_BACK .)
    KW_DO           reduce using rule 39 (robot_op -> OP_BACK .)
    COMMA           reduce using rule 39 (robot_op -> OP_BACK .)
    RPAREN          reduce using rule 39 (robot_op -> OP_BACK .)


state 30

    (40) robot_op -> OP_RIGHT .

    NEWLINE         reduce using rule 40 (robot_op -> OP_RIGHT .)
    TRUE            reduce using rule 40 (robot_op -> OP_RIGHT .)
    FALSE           reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_NOT          reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_GT           reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_LT           reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_EQ           reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_STEP         reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_BACK         reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_RIGHT        reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_LEFT         reduce using rule 40 (robot_op -> OP_RIGHT .)
    OP_LOOK         reduce using rule 40 (robot_op -> OP_RIGHT .)
    IDENTIFIER      reduce using rule 40 (robot_op -> OP_RIGHT .)
    INT_LITERAL     reduce using rule 40 (robot_op -> OP_RIGHT .)
    LPAREN          reduce using rule 40 (robot_op -> OP_RIGHT .)
    KW_DO           reduce using rule 40 (robot_op -> OP_RIGHT .)
    COMMA           reduce using rule 40 (robot_op -> OP_RIGHT .)
    RPAREN          reduce using rule 40 (robot_op -> OP_RIGHT .)


state 31

    (41) robot_op -> OP_LEFT .

    NEWLINE         reduce using rule 41 (robot_op -> OP_LEFT .)
    TRUE            reduce using rule 41 (robot_op -> OP_LEFT .)
    FALSE           reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_NOT          reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_GT           reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_LT           reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_EQ           reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_STEP         reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_BACK         reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_RIGHT        reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_LEFT         reduce using rule 41 (robot_op -> OP_LEFT .)
    OP_LOOK         reduce using rule 41 (robot_op -> OP_LEFT .)
    IDENTIFIER      reduce using rule 41 (robot_op -> OP_LEFT .)
    INT_LITERAL     reduce using rule 41 (robot_op -> OP_LEFT .)
    LPAREN          reduce using rule 41 (robot_op -> OP_LEFT .)
    KW_DO           reduce using rule 41 (robot_op -> OP_LEFT .)
    COMMA           reduce using rule 41 (robot_op -> OP_LEFT .)
    RPAREN          reduce using rule 41 (robot_op -> OP_LEFT .)


state 32

    (42) robot_op -> OP_LOOK .

    NEWLINE         reduce using rule 42 (robot_op -> OP_LOOK .)


state 33

    (43) map_op -> MAP_BAR . LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    LPAREN          shift and go to state 80


state 34

    (44) map_op -> MAP_EMP . LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    LPAREN          shift and go to state 81


state 35

    (45) map_op -> MAP_SET . LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    LPAREN          shift and go to state 82


state 36

    (46) map_op -> MAP_CLR . LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    LPAREN          shift and go to state 83


state 37

    (47) print_stmt -> KW_PRINT . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 84
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 38

    (4) stmt -> var_decl NEWLINE .

    NEWLINE         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_INT          reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_BOOLEAN      reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_CINT         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_CBOOLEAN     reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_MAP          reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_PROC         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    IDENTIFIER      reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_INC          reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_DEC          reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_IF           reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_WHILE        reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_STEP         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_BACK         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_RIGHT        reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_LEFT         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    OP_LOOK         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    MAP_BAR         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    MAP_EMP         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    MAP_SET         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    MAP_CLR         reduce using rule 4 (stmt -> var_decl NEWLINE .)
    KW_PRINT        reduce using rule 4 (stmt -> var_decl NEWLINE .)
    $end            reduce using rule 4 (stmt -> var_decl NEWLINE .)
    RPAREN          reduce using rule 4 (stmt -> var_decl NEWLINE .)


state 39

    (5) stmt -> const_decl NEWLINE .

    NEWLINE         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_INT          reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_BOOLEAN      reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_CINT         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_CBOOLEAN     reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_MAP          reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_PROC         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    IDENTIFIER      reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_INC          reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_DEC          reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_IF           reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_WHILE        reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_STEP         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_BACK         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_RIGHT        reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_LEFT         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    OP_LOOK         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    MAP_BAR         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    MAP_EMP         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    MAP_SET         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    MAP_CLR         reduce using rule 5 (stmt -> const_decl NEWLINE .)
    KW_PRINT        reduce using rule 5 (stmt -> const_decl NEWLINE .)
    $end            reduce using rule 5 (stmt -> const_decl NEWLINE .)
    RPAREN          reduce using rule 5 (stmt -> const_decl NEWLINE .)


state 40

    (6) stmt -> map_decl NEWLINE .

    NEWLINE         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_INT          reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_BOOLEAN      reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_CINT         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_CBOOLEAN     reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_MAP          reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_PROC         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    IDENTIFIER      reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_INC          reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_DEC          reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_IF           reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_WHILE        reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_STEP         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_BACK         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_RIGHT        reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_LEFT         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    OP_LOOK         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    MAP_BAR         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    MAP_EMP         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    MAP_SET         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    MAP_CLR         reduce using rule 6 (stmt -> map_decl NEWLINE .)
    KW_PRINT        reduce using rule 6 (stmt -> map_decl NEWLINE .)
    $end            reduce using rule 6 (stmt -> map_decl NEWLINE .)
    RPAREN          reduce using rule 6 (stmt -> map_decl NEWLINE .)


state 41

    (7) stmt -> proc_decl NEWLINE .

    NEWLINE         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_INT          reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_BOOLEAN      reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_CINT         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_CBOOLEAN     reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_MAP          reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_PROC         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    IDENTIFIER      reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_INC          reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_DEC          reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_IF           reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_WHILE        reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_STEP         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_BACK         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_RIGHT        reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_LEFT         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    OP_LOOK         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    MAP_BAR         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    MAP_EMP         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    MAP_SET         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    MAP_CLR         reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    KW_PRINT        reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    $end            reduce using rule 7 (stmt -> proc_decl NEWLINE .)
    RPAREN          reduce using rule 7 (stmt -> proc_decl NEWLINE .)


state 42

    (8) stmt -> assignment NEWLINE .

    NEWLINE         reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_INT          reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_BOOLEAN      reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_CINT         reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_CBOOLEAN     reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_MAP          reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_PROC         reduce using rule 8 (stmt -> assignment NEWLINE .)
    IDENTIFIER      reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_INC          reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_DEC          reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_IF           reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_WHILE        reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_STEP         reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_BACK         reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_RIGHT        reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_LEFT         reduce using rule 8 (stmt -> assignment NEWLINE .)
    OP_LOOK         reduce using rule 8 (stmt -> assignment NEWLINE .)
    MAP_BAR         reduce using rule 8 (stmt -> assignment NEWLINE .)
    MAP_EMP         reduce using rule 8 (stmt -> assignment NEWLINE .)
    MAP_SET         reduce using rule 8 (stmt -> assignment NEWLINE .)
    MAP_CLR         reduce using rule 8 (stmt -> assignment NEWLINE .)
    KW_PRINT        reduce using rule 8 (stmt -> assignment NEWLINE .)
    $end            reduce using rule 8 (stmt -> assignment NEWLINE .)
    RPAREN          reduce using rule 8 (stmt -> assignment NEWLINE .)


state 43

    (9) stmt -> incdec NEWLINE .

    NEWLINE         reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_INT          reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_BOOLEAN      reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_CINT         reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_CBOOLEAN     reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_MAP          reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_PROC         reduce using rule 9 (stmt -> incdec NEWLINE .)
    IDENTIFIER      reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_INC          reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_DEC          reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_IF           reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_WHILE        reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_STEP         reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_BACK         reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_RIGHT        reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_LEFT         reduce using rule 9 (stmt -> incdec NEWLINE .)
    OP_LOOK         reduce using rule 9 (stmt -> incdec NEWLINE .)
    MAP_BAR         reduce using rule 9 (stmt -> incdec NEWLINE .)
    MAP_EMP         reduce using rule 9 (stmt -> incdec NEWLINE .)
    MAP_SET         reduce using rule 9 (stmt -> incdec NEWLINE .)
    MAP_CLR         reduce using rule 9 (stmt -> incdec NEWLINE .)
    KW_PRINT        reduce using rule 9 (stmt -> incdec NEWLINE .)
    $end            reduce using rule 9 (stmt -> incdec NEWLINE .)
    RPAREN          reduce using rule 9 (stmt -> incdec NEWLINE .)


state 44

    (10) stmt -> if_stmt NEWLINE .

    NEWLINE         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_INT          reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_BOOLEAN      reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_CINT         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_CBOOLEAN     reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_MAP          reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_PROC         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_INC          reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_DEC          reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_IF           reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_WHILE        reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_STEP         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_BACK         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_RIGHT        reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_LEFT         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    OP_LOOK         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    MAP_BAR         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    MAP_EMP         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    MAP_SET         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    MAP_CLR         reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    KW_PRINT        reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    $end            reduce using rule 10 (stmt -> if_stmt NEWLINE .)
    RPAREN          reduce using rule 10 (stmt -> if_stmt NEWLINE .)


state 45

    (11) stmt -> while_stmt NEWLINE .

    NEWLINE         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_INT          reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_BOOLEAN      reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_CINT         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_CBOOLEAN     reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_MAP          reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_PROC         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_INC          reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_DEC          reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_IF           reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_WHILE        reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_STEP         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_BACK         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_RIGHT        reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_LEFT         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    OP_LOOK         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    MAP_BAR         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    MAP_EMP         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    MAP_SET         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    MAP_CLR         reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    KW_PRINT        reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    $end            reduce using rule 11 (stmt -> while_stmt NEWLINE .)
    RPAREN          reduce using rule 11 (stmt -> while_stmt NEWLINE .)


state 46

    (12) stmt -> proc_call NEWLINE .

    NEWLINE         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_INT          reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_BOOLEAN      reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_CINT         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_CBOOLEAN     reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_MAP          reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_PROC         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    IDENTIFIER      reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_INC          reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_DEC          reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_IF           reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_WHILE        reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_STEP         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_BACK         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_RIGHT        reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_LEFT         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    OP_LOOK         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    MAP_BAR         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    MAP_EMP         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    MAP_SET         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    MAP_CLR         reduce using rule 12 (stmt -> proc_call NEWLINE .)
    KW_PRINT        reduce using rule 12 (stmt -> proc_call NEWLINE .)
    $end            reduce using rule 12 (stmt -> proc_call NEWLINE .)
    RPAREN          reduce using rule 12 (stmt -> proc_call NEWLINE .)


state 47

    (13) stmt -> robot_op NEWLINE .

    NEWLINE         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_INT          reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_BOOLEAN      reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_CINT         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_CBOOLEAN     reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_MAP          reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_PROC         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    IDENTIFIER      reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_INC          reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_DEC          reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_IF           reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_WHILE        reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_STEP         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_BACK         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_RIGHT        reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_LEFT         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    OP_LOOK         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    MAP_BAR         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    MAP_EMP         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    MAP_SET         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    MAP_CLR         reduce using rule 13 (stmt -> robot_op NEWLINE .)
    KW_PRINT        reduce using rule 13 (stmt -> robot_op NEWLINE .)
    $end            reduce using rule 13 (stmt -> robot_op NEWLINE .)
    RPAREN          reduce using rule 13 (stmt -> robot_op NEWLINE .)


state 48

    (14) stmt -> map_op NEWLINE .

    NEWLINE         reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_INT          reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_BOOLEAN      reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_CINT         reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_CBOOLEAN     reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_MAP          reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_PROC         reduce using rule 14 (stmt -> map_op NEWLINE .)
    IDENTIFIER      reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_INC          reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_DEC          reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_IF           reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_WHILE        reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_STEP         reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_BACK         reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_RIGHT        reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_LEFT         reduce using rule 14 (stmt -> map_op NEWLINE .)
    OP_LOOK         reduce using rule 14 (stmt -> map_op NEWLINE .)
    MAP_BAR         reduce using rule 14 (stmt -> map_op NEWLINE .)
    MAP_EMP         reduce using rule 14 (stmt -> map_op NEWLINE .)
    MAP_SET         reduce using rule 14 (stmt -> map_op NEWLINE .)
    MAP_CLR         reduce using rule 14 (stmt -> map_op NEWLINE .)
    KW_PRINT        reduce using rule 14 (stmt -> map_op NEWLINE .)
    $end            reduce using rule 14 (stmt -> map_op NEWLINE .)
    RPAREN          reduce using rule 14 (stmt -> map_op NEWLINE .)


state 49

    (15) stmt -> print_stmt NEWLINE .

    NEWLINE         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_INT          reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_BOOLEAN      reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_CINT         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_CBOOLEAN     reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_MAP          reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_PROC         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    IDENTIFIER      reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_INC          reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_DEC          reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_IF           reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_WHILE        reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_STEP         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_BACK         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_RIGHT        reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_LEFT         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    OP_LOOK         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    MAP_BAR         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    MAP_EMP         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    MAP_SET         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    MAP_CLR         reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    KW_PRINT        reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    $end            reduce using rule 15 (stmt -> print_stmt NEWLINE .)
    RPAREN          reduce using rule 15 (stmt -> print_stmt NEWLINE .)


state 50

    (17) var_decl -> KW_INT IDENTIFIER . OP_ASSIGN expr

    OP_ASSIGN       shift and go to state 85


state 51

    (25) param_list -> IDENTIFIER .

    IDENTIFIER      reduce using rule 25 (param_list -> IDENTIFIER .)
    NEWLINE         reduce using rule 25 (param_list -> IDENTIFIER .)
    LPAREN          reduce using rule 25 (param_list -> IDENTIFIER .)
    TRUE            reduce using rule 25 (param_list -> IDENTIFIER .)
    FALSE           reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_NOT          reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_GT           reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_LT           reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_EQ           reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_STEP         reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_BACK         reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_RIGHT        reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_LEFT         reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_LOOK         reduce using rule 25 (param_list -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 25 (param_list -> IDENTIFIER .)
    +               reduce using rule 25 (param_list -> IDENTIFIER .)
    -               reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_INC          reduce using rule 25 (param_list -> IDENTIFIER .)
    OP_DEC          reduce using rule 25 (param_list -> IDENTIFIER .)
    KW_DO           reduce using rule 25 (param_list -> IDENTIFIER .)
    COMMA           reduce using rule 25 (param_list -> IDENTIFIER .)
    RPAREN          reduce using rule 25 (param_list -> IDENTIFIER .)


state 52

    (30) assignment -> IDENTIFIER OP_ASSIGN . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 86
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 53

    (37) proc_call -> IDENTIFIER param_list_opt .

    NEWLINE         reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    TRUE            reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    FALSE           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_NOT          reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_GT           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_LT           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_EQ           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_STEP         reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_BACK         reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_RIGHT        reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_LEFT         reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_LOOK         reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    IDENTIFIER      reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    INT_LITERAL     reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    +               reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    -               reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_INC          reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    OP_DEC          reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    LPAREN          reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    KW_DO           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    COMMA           reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)
    RPAREN          reduce using rule 37 (proc_call -> IDENTIFIER param_list_opt .)


state 54

    (23) param_list_opt -> param_list .
    (26) param_list -> param_list . IDENTIFIER

  ! shift/reduce conflict for IDENTIFIER resolved as shift
    NEWLINE         reduce using rule 23 (param_list_opt -> param_list .)
    LPAREN          reduce using rule 23 (param_list_opt -> param_list .)
    TRUE            reduce using rule 23 (param_list_opt -> param_list .)
    FALSE           reduce using rule 23 (param_list_opt -> param_list .)
    OP_NOT          reduce using rule 23 (param_list_opt -> param_list .)
    OP_GT           reduce using rule 23 (param_list_opt -> param_list .)
    OP_LT           reduce using rule 23 (param_list_opt -> param_list .)
    OP_EQ           reduce using rule 23 (param_list_opt -> param_list .)
    OP_STEP         reduce using rule 23 (param_list_opt -> param_list .)
    OP_BACK         reduce using rule 23 (param_list_opt -> param_list .)
    OP_RIGHT        reduce using rule 23 (param_list_opt -> param_list .)
    OP_LEFT         reduce using rule 23 (param_list_opt -> param_list .)
    OP_LOOK         reduce using rule 23 (param_list_opt -> param_list .)
    INT_LITERAL     reduce using rule 23 (param_list_opt -> param_list .)
    +               reduce using rule 23 (param_list_opt -> param_list .)
    -               reduce using rule 23 (param_list_opt -> param_list .)
    OP_INC          reduce using rule 23 (param_list_opt -> param_list .)
    OP_DEC          reduce using rule 23 (param_list_opt -> param_list .)
    KW_DO           reduce using rule 23 (param_list_opt -> param_list .)
    COMMA           reduce using rule 23 (param_list_opt -> param_list .)
    RPAREN          reduce using rule 23 (param_list_opt -> param_list .)
    IDENTIFIER      shift and go to state 87

  ! IDENTIFIER      [ reduce using rule 23 (param_list_opt -> param_list .) ]


state 55

    (24) param_list_opt -> empty .

    NEWLINE         reduce using rule 24 (param_list_opt -> empty .)
    LPAREN          reduce using rule 24 (param_list_opt -> empty .)
    TRUE            reduce using rule 24 (param_list_opt -> empty .)
    FALSE           reduce using rule 24 (param_list_opt -> empty .)
    OP_NOT          reduce using rule 24 (param_list_opt -> empty .)
    OP_GT           reduce using rule 24 (param_list_opt -> empty .)
    OP_LT           reduce using rule 24 (param_list_opt -> empty .)
    OP_EQ           reduce using rule 24 (param_list_opt -> empty .)
    OP_STEP         reduce using rule 24 (param_list_opt -> empty .)
    OP_BACK         reduce using rule 24 (param_list_opt -> empty .)
    OP_RIGHT        reduce using rule 24 (param_list_opt -> empty .)
    OP_LEFT         reduce using rule 24 (param_list_opt -> empty .)
    OP_LOOK         reduce using rule 24 (param_list_opt -> empty .)
    IDENTIFIER      reduce using rule 24 (param_list_opt -> empty .)
    INT_LITERAL     reduce using rule 24 (param_list_opt -> empty .)
    +               reduce using rule 24 (param_list_opt -> empty .)
    -               reduce using rule 24 (param_list_opt -> empty .)
    OP_INC          reduce using rule 24 (param_list_opt -> empty .)
    OP_DEC          reduce using rule 24 (param_list_opt -> empty .)
    KW_DO           reduce using rule 24 (param_list_opt -> empty .)
    COMMA           reduce using rule 24 (param_list_opt -> empty .)
    RPAREN          reduce using rule 24 (param_list_opt -> empty .)


state 56

    (18) var_decl -> KW_BOOLEAN IDENTIFIER . OP_ASSIGN expr

    OP_ASSIGN       shift and go to state 88


state 57

    (19) const_decl -> KW_CINT IDENTIFIER . OP_ASSIGN expr

    OP_ASSIGN       shift and go to state 89


state 58

    (20) const_decl -> KW_CBOOLEAN IDENTIFIER . OP_ASSIGN expr

    OP_ASSIGN       shift and go to state 90


state 59

    (21) map_decl -> KW_MAP IDENTIFIER .

    NEWLINE         reduce using rule 21 (map_decl -> KW_MAP IDENTIFIER .)


state 60

    (22) proc_decl -> KW_PROC IDENTIFIER . param_list_opt block
    (23) param_list_opt -> . param_list
    (24) param_list_opt -> . empty
    (25) param_list -> . IDENTIFIER
    (26) param_list -> . param_list IDENTIFIER
    (68) empty -> .

    IDENTIFIER      shift and go to state 51
    LPAREN          reduce using rule 68 (empty -> .)

    param_list_opt                 shift and go to state 91
    param_list                     shift and go to state 54
    empty                          shift and go to state 55

state 61

    (31) incdec -> OP_INC expr . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 92
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 62

    (48) expr -> arith_expr .
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    TRUE            reduce using rule 48 (expr -> arith_expr .)
    FALSE           reduce using rule 48 (expr -> arith_expr .)
    OP_NOT          reduce using rule 48 (expr -> arith_expr .)
    OP_GT           reduce using rule 48 (expr -> arith_expr .)
    OP_LT           reduce using rule 48 (expr -> arith_expr .)
    OP_EQ           reduce using rule 48 (expr -> arith_expr .)
    OP_STEP         reduce using rule 48 (expr -> arith_expr .)
    OP_BACK         reduce using rule 48 (expr -> arith_expr .)
    OP_RIGHT        reduce using rule 48 (expr -> arith_expr .)
    OP_LEFT         reduce using rule 48 (expr -> arith_expr .)
    OP_LOOK         reduce using rule 48 (expr -> arith_expr .)
    IDENTIFIER      reduce using rule 48 (expr -> arith_expr .)
    INT_LITERAL     reduce using rule 48 (expr -> arith_expr .)
    LPAREN          reduce using rule 48 (expr -> arith_expr .)
    KW_DO           reduce using rule 48 (expr -> arith_expr .)
    NEWLINE         reduce using rule 48 (expr -> arith_expr .)
    COMMA           reduce using rule 48 (expr -> arith_expr .)
    RPAREN          reduce using rule 48 (expr -> arith_expr .)
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 63

    (49) expr -> logic_expr .
    (67) logic_expr -> logic_expr . OP_OR logic_expr

    TRUE            reduce using rule 49 (expr -> logic_expr .)
    FALSE           reduce using rule 49 (expr -> logic_expr .)
    OP_NOT          reduce using rule 49 (expr -> logic_expr .)
    OP_GT           reduce using rule 49 (expr -> logic_expr .)
    OP_LT           reduce using rule 49 (expr -> logic_expr .)
    OP_EQ           reduce using rule 49 (expr -> logic_expr .)
    OP_STEP         reduce using rule 49 (expr -> logic_expr .)
    OP_BACK         reduce using rule 49 (expr -> logic_expr .)
    OP_RIGHT        reduce using rule 49 (expr -> logic_expr .)
    OP_LEFT         reduce using rule 49 (expr -> logic_expr .)
    OP_LOOK         reduce using rule 49 (expr -> logic_expr .)
    IDENTIFIER      reduce using rule 49 (expr -> logic_expr .)
    INT_LITERAL     reduce using rule 49 (expr -> logic_expr .)
    LPAREN          reduce using rule 49 (expr -> logic_expr .)
    KW_DO           reduce using rule 49 (expr -> logic_expr .)
    NEWLINE         reduce using rule 49 (expr -> logic_expr .)
    COMMA           reduce using rule 49 (expr -> logic_expr .)
    RPAREN          reduce using rule 49 (expr -> logic_expr .)
    OP_OR           shift and go to state 97


state 64

    (50) expr -> robot_op .

    TRUE            reduce using rule 50 (expr -> robot_op .)
    FALSE           reduce using rule 50 (expr -> robot_op .)
    OP_NOT          reduce using rule 50 (expr -> robot_op .)
    OP_GT           reduce using rule 50 (expr -> robot_op .)
    OP_LT           reduce using rule 50 (expr -> robot_op .)
    OP_EQ           reduce using rule 50 (expr -> robot_op .)
    OP_STEP         reduce using rule 50 (expr -> robot_op .)
    OP_BACK         reduce using rule 50 (expr -> robot_op .)
    OP_RIGHT        reduce using rule 50 (expr -> robot_op .)
    OP_LEFT         reduce using rule 50 (expr -> robot_op .)
    OP_LOOK         reduce using rule 50 (expr -> robot_op .)
    IDENTIFIER      reduce using rule 50 (expr -> robot_op .)
    INT_LITERAL     reduce using rule 50 (expr -> robot_op .)
    LPAREN          reduce using rule 50 (expr -> robot_op .)
    KW_DO           reduce using rule 50 (expr -> robot_op .)
    NEWLINE         reduce using rule 50 (expr -> robot_op .)
    COMMA           reduce using rule 50 (expr -> robot_op .)
    RPAREN          reduce using rule 50 (expr -> robot_op .)


state 65

    (51) expr -> proc_call .
    (59) term -> proc_call .

  ! reduce/reduce conflict for TRUE resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for FALSE resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_NOT resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_GT resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_LT resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_EQ resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_STEP resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_BACK resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_RIGHT resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_LEFT resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for OP_LOOK resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for LPAREN resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for KW_DO resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for COMMA resolved using rule 51 (expr -> proc_call .)
  ! reduce/reduce conflict for RPAREN resolved using rule 51 (expr -> proc_call .)
    TRUE            reduce using rule 51 (expr -> proc_call .)
    FALSE           reduce using rule 51 (expr -> proc_call .)
    OP_NOT          reduce using rule 51 (expr -> proc_call .)
    OP_GT           reduce using rule 51 (expr -> proc_call .)
    OP_LT           reduce using rule 51 (expr -> proc_call .)
    OP_EQ           reduce using rule 51 (expr -> proc_call .)
    OP_STEP         reduce using rule 51 (expr -> proc_call .)
    OP_BACK         reduce using rule 51 (expr -> proc_call .)
    OP_RIGHT        reduce using rule 51 (expr -> proc_call .)
    OP_LEFT         reduce using rule 51 (expr -> proc_call .)
    OP_LOOK         reduce using rule 51 (expr -> proc_call .)
    IDENTIFIER      reduce using rule 51 (expr -> proc_call .)
    INT_LITERAL     reduce using rule 51 (expr -> proc_call .)
    LPAREN          reduce using rule 51 (expr -> proc_call .)
    KW_DO           reduce using rule 51 (expr -> proc_call .)
    NEWLINE         reduce using rule 51 (expr -> proc_call .)
    COMMA           reduce using rule 51 (expr -> proc_call .)
    RPAREN          reduce using rule 51 (expr -> proc_call .)
    +               reduce using rule 59 (term -> proc_call .)
    -               reduce using rule 59 (term -> proc_call .)
    OP_INC          reduce using rule 59 (term -> proc_call .)
    OP_DEC          reduce using rule 59 (term -> proc_call .)

  ! TRUE            [ reduce using rule 59 (term -> proc_call .) ]
  ! FALSE           [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_NOT          [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_GT           [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_LT           [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_EQ           [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_STEP         [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_BACK         [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_RIGHT        [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_LEFT         [ reduce using rule 59 (term -> proc_call .) ]
  ! OP_LOOK         [ reduce using rule 59 (term -> proc_call .) ]
  ! IDENTIFIER      [ reduce using rule 59 (term -> proc_call .) ]
  ! INT_LITERAL     [ reduce using rule 59 (term -> proc_call .) ]
  ! LPAREN          [ reduce using rule 59 (term -> proc_call .) ]
  ! KW_DO           [ reduce using rule 59 (term -> proc_call .) ]
  ! NEWLINE         [ reduce using rule 59 (term -> proc_call .) ]
  ! COMMA           [ reduce using rule 59 (term -> proc_call .) ]
  ! RPAREN          [ reduce using rule 59 (term -> proc_call .) ]


state 66

    (56) arith_expr -> term .

    +               reduce using rule 56 (arith_expr -> term .)
    -               reduce using rule 56 (arith_expr -> term .)
    OP_INC          reduce using rule 56 (arith_expr -> term .)
    OP_DEC          reduce using rule 56 (arith_expr -> term .)
    TRUE            reduce using rule 56 (arith_expr -> term .)
    FALSE           reduce using rule 56 (arith_expr -> term .)
    OP_NOT          reduce using rule 56 (arith_expr -> term .)
    OP_GT           reduce using rule 56 (arith_expr -> term .)
    OP_LT           reduce using rule 56 (arith_expr -> term .)
    OP_EQ           reduce using rule 56 (arith_expr -> term .)
    OP_STEP         reduce using rule 56 (arith_expr -> term .)
    OP_BACK         reduce using rule 56 (arith_expr -> term .)
    OP_RIGHT        reduce using rule 56 (arith_expr -> term .)
    OP_LEFT         reduce using rule 56 (arith_expr -> term .)
    OP_LOOK         reduce using rule 56 (arith_expr -> term .)
    IDENTIFIER      reduce using rule 56 (arith_expr -> term .)
    INT_LITERAL     reduce using rule 56 (arith_expr -> term .)
    LPAREN          reduce using rule 56 (arith_expr -> term .)
    KW_DO           reduce using rule 56 (arith_expr -> term .)
    NEWLINE         reduce using rule 56 (arith_expr -> term .)
    COMMA           reduce using rule 56 (arith_expr -> term .)
    RPAREN          reduce using rule 56 (arith_expr -> term .)


state 67

    (61) logic_expr -> TRUE .

    OP_OR           reduce using rule 61 (logic_expr -> TRUE .)
    TRUE            reduce using rule 61 (logic_expr -> TRUE .)
    FALSE           reduce using rule 61 (logic_expr -> TRUE .)
    OP_NOT          reduce using rule 61 (logic_expr -> TRUE .)
    OP_GT           reduce using rule 61 (logic_expr -> TRUE .)
    OP_LT           reduce using rule 61 (logic_expr -> TRUE .)
    OP_EQ           reduce using rule 61 (logic_expr -> TRUE .)
    OP_STEP         reduce using rule 61 (logic_expr -> TRUE .)
    OP_BACK         reduce using rule 61 (logic_expr -> TRUE .)
    OP_RIGHT        reduce using rule 61 (logic_expr -> TRUE .)
    OP_LEFT         reduce using rule 61 (logic_expr -> TRUE .)
    OP_LOOK         reduce using rule 61 (logic_expr -> TRUE .)
    IDENTIFIER      reduce using rule 61 (logic_expr -> TRUE .)
    INT_LITERAL     reduce using rule 61 (logic_expr -> TRUE .)
    LPAREN          reduce using rule 61 (logic_expr -> TRUE .)
    KW_DO           reduce using rule 61 (logic_expr -> TRUE .)
    NEWLINE         reduce using rule 61 (logic_expr -> TRUE .)
    RPAREN          reduce using rule 61 (logic_expr -> TRUE .)
    COMMA           reduce using rule 61 (logic_expr -> TRUE .)


state 68

    (62) logic_expr -> FALSE .

    OP_OR           reduce using rule 62 (logic_expr -> FALSE .)
    TRUE            reduce using rule 62 (logic_expr -> FALSE .)
    FALSE           reduce using rule 62 (logic_expr -> FALSE .)
    OP_NOT          reduce using rule 62 (logic_expr -> FALSE .)
    OP_GT           reduce using rule 62 (logic_expr -> FALSE .)
    OP_LT           reduce using rule 62 (logic_expr -> FALSE .)
    OP_EQ           reduce using rule 62 (logic_expr -> FALSE .)
    OP_STEP         reduce using rule 62 (logic_expr -> FALSE .)
    OP_BACK         reduce using rule 62 (logic_expr -> FALSE .)
    OP_RIGHT        reduce using rule 62 (logic_expr -> FALSE .)
    OP_LEFT         reduce using rule 62 (logic_expr -> FALSE .)
    OP_LOOK         reduce using rule 62 (logic_expr -> FALSE .)
    IDENTIFIER      reduce using rule 62 (logic_expr -> FALSE .)
    INT_LITERAL     reduce using rule 62 (logic_expr -> FALSE .)
    LPAREN          reduce using rule 62 (logic_expr -> FALSE .)
    KW_DO           reduce using rule 62 (logic_expr -> FALSE .)
    NEWLINE         reduce using rule 62 (logic_expr -> FALSE .)
    RPAREN          reduce using rule 62 (logic_expr -> FALSE .)
    COMMA           reduce using rule 62 (logic_expr -> FALSE .)


state 69

    (63) logic_expr -> OP_NOT . LPAREN logic_expr RPAREN

    LPAREN          shift and go to state 98


state 70

    (64) logic_expr -> OP_GT . LPAREN expr COMMA expr RPAREN

    LPAREN          shift and go to state 99


state 71

    (65) logic_expr -> OP_LT . LPAREN expr COMMA expr RPAREN

    LPAREN          shift and go to state 100


state 72

    (66) logic_expr -> OP_EQ . LPAREN expr COMMA expr RPAREN

    LPAREN          shift and go to state 101


state 73

    (37) proc_call -> IDENTIFIER . param_list_opt
    (58) term -> IDENTIFIER .
    (23) param_list_opt -> . param_list
    (24) param_list_opt -> . empty
    (25) param_list -> . IDENTIFIER
    (26) param_list -> . param_list IDENTIFIER
    (68) empty -> .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for TRUE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for FALSE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_NOT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_GT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_EQ resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_STEP resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_BACK resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_RIGHT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LEFT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LOOK resolved using rule 58 (term -> IDENTIFIER .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for + resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for - resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_INC resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_DEC resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for KW_DO resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 58 (term -> IDENTIFIER .)
    +               reduce using rule 58 (term -> IDENTIFIER .)
    -               reduce using rule 58 (term -> IDENTIFIER .)
    OP_INC          reduce using rule 58 (term -> IDENTIFIER .)
    OP_DEC          reduce using rule 58 (term -> IDENTIFIER .)
    TRUE            reduce using rule 58 (term -> IDENTIFIER .)
    FALSE           reduce using rule 58 (term -> IDENTIFIER .)
    OP_NOT          reduce using rule 58 (term -> IDENTIFIER .)
    OP_GT           reduce using rule 58 (term -> IDENTIFIER .)
    OP_LT           reduce using rule 58 (term -> IDENTIFIER .)
    OP_EQ           reduce using rule 58 (term -> IDENTIFIER .)
    OP_STEP         reduce using rule 58 (term -> IDENTIFIER .)
    OP_BACK         reduce using rule 58 (term -> IDENTIFIER .)
    OP_RIGHT        reduce using rule 58 (term -> IDENTIFIER .)
    OP_LEFT         reduce using rule 58 (term -> IDENTIFIER .)
    OP_LOOK         reduce using rule 58 (term -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 58 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 58 (term -> IDENTIFIER .)
    KW_DO           reduce using rule 58 (term -> IDENTIFIER .)
    NEWLINE         reduce using rule 58 (term -> IDENTIFIER .)
    COMMA           reduce using rule 58 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 58 (term -> IDENTIFIER .)
    IDENTIFIER      shift and go to state 51

  ! IDENTIFIER      [ reduce using rule 58 (term -> IDENTIFIER .) ]
  ! TRUE            [ reduce using rule 68 (empty -> .) ]
  ! FALSE           [ reduce using rule 68 (empty -> .) ]
  ! OP_NOT          [ reduce using rule 68 (empty -> .) ]
  ! OP_GT           [ reduce using rule 68 (empty -> .) ]
  ! OP_LT           [ reduce using rule 68 (empty -> .) ]
  ! OP_EQ           [ reduce using rule 68 (empty -> .) ]
  ! OP_STEP         [ reduce using rule 68 (empty -> .) ]
  ! OP_BACK         [ reduce using rule 68 (empty -> .) ]
  ! OP_RIGHT        [ reduce using rule 68 (empty -> .) ]
  ! OP_LEFT         [ reduce using rule 68 (empty -> .) ]
  ! OP_LOOK         [ reduce using rule 68 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 68 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 68 (empty -> .) ]
  ! +               [ reduce using rule 68 (empty -> .) ]
  ! -               [ reduce using rule 68 (empty -> .) ]
  ! OP_INC          [ reduce using rule 68 (empty -> .) ]
  ! OP_DEC          [ reduce using rule 68 (empty -> .) ]
  ! LPAREN          [ reduce using rule 68 (empty -> .) ]
  ! KW_DO           [ reduce using rule 68 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 68 (empty -> .) ]
  ! COMMA           [ reduce using rule 68 (empty -> .) ]
  ! RPAREN          [ reduce using rule 68 (empty -> .) ]

    param_list_opt                 shift and go to state 53
    param_list                     shift and go to state 54
    empty                          shift and go to state 55

state 74

    (42) robot_op -> OP_LOOK .
    (60) term -> OP_LOOK .

  ! reduce/reduce conflict for TRUE resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for FALSE resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_NOT resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_GT resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_LT resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_EQ resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_STEP resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_BACK resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_RIGHT resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_LEFT resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for OP_LOOK resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for IDENTIFIER resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for LPAREN resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for KW_DO resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for COMMA resolved using rule 42 (robot_op -> OP_LOOK .)
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (robot_op -> OP_LOOK .)
    TRUE            reduce using rule 42 (robot_op -> OP_LOOK .)
    FALSE           reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_NOT          reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_GT           reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_LT           reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_EQ           reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_STEP         reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_BACK         reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_RIGHT        reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_LEFT         reduce using rule 42 (robot_op -> OP_LOOK .)
    OP_LOOK         reduce using rule 42 (robot_op -> OP_LOOK .)
    IDENTIFIER      reduce using rule 42 (robot_op -> OP_LOOK .)
    INT_LITERAL     reduce using rule 42 (robot_op -> OP_LOOK .)
    LPAREN          reduce using rule 42 (robot_op -> OP_LOOK .)
    KW_DO           reduce using rule 42 (robot_op -> OP_LOOK .)
    NEWLINE         reduce using rule 42 (robot_op -> OP_LOOK .)
    COMMA           reduce using rule 42 (robot_op -> OP_LOOK .)
    RPAREN          reduce using rule 42 (robot_op -> OP_LOOK .)
    +               reduce using rule 60 (term -> OP_LOOK .)
    -               reduce using rule 60 (term -> OP_LOOK .)
    OP_INC          reduce using rule 60 (term -> OP_LOOK .)
    OP_DEC          reduce using rule 60 (term -> OP_LOOK .)

  ! TRUE            [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! FALSE           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_NOT          [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_GT           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_LT           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_EQ           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_STEP         [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_BACK         [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_RIGHT        [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_LEFT         [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! OP_LOOK         [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! IDENTIFIER      [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! INT_LITERAL     [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! LPAREN          [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! KW_DO           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! NEWLINE         [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! COMMA           [ reduce using rule 60 (term -> OP_LOOK .) ]
  ! RPAREN          [ reduce using rule 60 (term -> OP_LOOK .) ]


state 75

    (57) term -> INT_LITERAL .

    +               reduce using rule 57 (term -> INT_LITERAL .)
    -               reduce using rule 57 (term -> INT_LITERAL .)
    OP_INC          reduce using rule 57 (term -> INT_LITERAL .)
    OP_DEC          reduce using rule 57 (term -> INT_LITERAL .)
    TRUE            reduce using rule 57 (term -> INT_LITERAL .)
    FALSE           reduce using rule 57 (term -> INT_LITERAL .)
    OP_NOT          reduce using rule 57 (term -> INT_LITERAL .)
    OP_GT           reduce using rule 57 (term -> INT_LITERAL .)
    OP_LT           reduce using rule 57 (term -> INT_LITERAL .)
    OP_EQ           reduce using rule 57 (term -> INT_LITERAL .)
    OP_STEP         reduce using rule 57 (term -> INT_LITERAL .)
    OP_BACK         reduce using rule 57 (term -> INT_LITERAL .)
    OP_RIGHT        reduce using rule 57 (term -> INT_LITERAL .)
    OP_LEFT         reduce using rule 57 (term -> INT_LITERAL .)
    OP_LOOK         reduce using rule 57 (term -> INT_LITERAL .)
    IDENTIFIER      reduce using rule 57 (term -> INT_LITERAL .)
    INT_LITERAL     reduce using rule 57 (term -> INT_LITERAL .)
    LPAREN          reduce using rule 57 (term -> INT_LITERAL .)
    KW_DO           reduce using rule 57 (term -> INT_LITERAL .)
    NEWLINE         reduce using rule 57 (term -> INT_LITERAL .)
    COMMA           reduce using rule 57 (term -> INT_LITERAL .)
    RPAREN          reduce using rule 57 (term -> INT_LITERAL .)


state 76

    (32) incdec -> OP_DEC expr . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 102
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 77

    (33) if_stmt -> KW_IF expr . block else_opt
    (27) block -> . LPAREN opt_nl stmt_list opt_nl RPAREN

    LPAREN          shift and go to state 104

    block                          shift and go to state 103

state 78

    (36) while_stmt -> KW_WHILE expr . KW_DO block

    KW_DO           shift and go to state 105


state 79

    (38) robot_op -> OP_STEP IDENTIFIER .

    NEWLINE         reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    TRUE            reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    FALSE           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_NOT          reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_GT           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_LT           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_EQ           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_STEP         reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_BACK         reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_RIGHT        reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_LEFT         reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    OP_LOOK         reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    IDENTIFIER      reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    INT_LITERAL     reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    LPAREN          reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    KW_DO           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    COMMA           reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)
    RPAREN          reduce using rule 38 (robot_op -> OP_STEP IDENTIFIER .)


state 80

    (43) map_op -> MAP_BAR LPAREN . IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 106


state 81

    (44) map_op -> MAP_EMP LPAREN . IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 107


state 82

    (45) map_op -> MAP_SET LPAREN . IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 108


state 83

    (46) map_op -> MAP_CLR LPAREN . IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 109


state 84

    (47) print_stmt -> KW_PRINT expr .

    NEWLINE         reduce using rule 47 (print_stmt -> KW_PRINT expr .)


state 85

    (17) var_decl -> KW_INT IDENTIFIER OP_ASSIGN . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 110
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 86

    (30) assignment -> IDENTIFIER OP_ASSIGN expr .

    NEWLINE         reduce using rule 30 (assignment -> IDENTIFIER OP_ASSIGN expr .)


state 87

    (26) param_list -> param_list IDENTIFIER .

    IDENTIFIER      reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    NEWLINE         reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    LPAREN          reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    TRUE            reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    FALSE           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_NOT          reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_GT           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_LT           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_EQ           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_STEP         reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_BACK         reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_RIGHT        reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_LEFT         reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_LOOK         reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    INT_LITERAL     reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    +               reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    -               reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_INC          reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    OP_DEC          reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    KW_DO           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    COMMA           reduce using rule 26 (param_list -> param_list IDENTIFIER .)
    RPAREN          reduce using rule 26 (param_list -> param_list IDENTIFIER .)


state 88

    (18) var_decl -> KW_BOOLEAN IDENTIFIER OP_ASSIGN . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 111
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 89

    (19) const_decl -> KW_CINT IDENTIFIER OP_ASSIGN . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 112
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 90

    (20) const_decl -> KW_CBOOLEAN IDENTIFIER OP_ASSIGN . expr
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 113
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 91

    (22) proc_decl -> KW_PROC IDENTIFIER param_list_opt . block
    (27) block -> . LPAREN opt_nl stmt_list opt_nl RPAREN

    LPAREN          shift and go to state 104

    block                          shift and go to state 114

state 92

    (31) incdec -> OP_INC expr expr .

    NEWLINE         reduce using rule 31 (incdec -> OP_INC expr expr .)


state 93

    (52) arith_expr -> arith_expr + . arith_expr
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 115
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 94

    (53) arith_expr -> arith_expr - . arith_expr
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 119
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 95

    (54) arith_expr -> arith_expr OP_INC . arith_expr
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 120
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 96

    (55) arith_expr -> arith_expr OP_DEC . arith_expr
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 121
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 97

    (67) logic_expr -> logic_expr OP_OR . logic_expr
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72

    logic_expr                     shift and go to state 122

state 98

    (63) logic_expr -> OP_NOT LPAREN . logic_expr RPAREN
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72

    logic_expr                     shift and go to state 123

state 99

    (64) logic_expr -> OP_GT LPAREN . expr COMMA expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 124
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 100

    (65) logic_expr -> OP_LT LPAREN . expr COMMA expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 125
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 101

    (66) logic_expr -> OP_EQ LPAREN . expr COMMA expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 126
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 102

    (32) incdec -> OP_DEC expr expr .

    NEWLINE         reduce using rule 32 (incdec -> OP_DEC expr expr .)


state 103

    (33) if_stmt -> KW_IF expr block . else_opt
    (34) else_opt -> . KW_ELSE block
    (35) else_opt -> . empty
    (68) empty -> .

    KW_ELSE         shift and go to state 128
    NEWLINE         reduce using rule 68 (empty -> .)

    else_opt                       shift and go to state 127
    empty                          shift and go to state 129

state 104

    (27) block -> LPAREN . opt_nl stmt_list opt_nl RPAREN
    (28) opt_nl -> . opt_nl NEWLINE
    (29) opt_nl -> . empty
    (68) empty -> .

    NEWLINE         reduce using rule 68 (empty -> .)
    KW_INT          reduce using rule 68 (empty -> .)
    KW_BOOLEAN      reduce using rule 68 (empty -> .)
    KW_CINT         reduce using rule 68 (empty -> .)
    KW_CBOOLEAN     reduce using rule 68 (empty -> .)
    KW_MAP          reduce using rule 68 (empty -> .)
    KW_PROC         reduce using rule 68 (empty -> .)
    IDENTIFIER      reduce using rule 68 (empty -> .)
    OP_INC          reduce using rule 68 (empty -> .)
    OP_DEC          reduce using rule 68 (empty -> .)
    KW_IF           reduce using rule 68 (empty -> .)
    KW_WHILE        reduce using rule 68 (empty -> .)
    OP_STEP         reduce using rule 68 (empty -> .)
    OP_BACK         reduce using rule 68 (empty -> .)
    OP_RIGHT        reduce using rule 68 (empty -> .)
    OP_LEFT         reduce using rule 68 (empty -> .)
    OP_LOOK         reduce using rule 68 (empty -> .)
    MAP_BAR         reduce using rule 68 (empty -> .)
    MAP_EMP         reduce using rule 68 (empty -> .)
    MAP_SET         reduce using rule 68 (empty -> .)
    MAP_CLR         reduce using rule 68 (empty -> .)
    KW_PRINT        reduce using rule 68 (empty -> .)
    RPAREN          reduce using rule 68 (empty -> .)

    opt_nl                         shift and go to state 130
    empty                          shift and go to state 131

state 105

    (36) while_stmt -> KW_WHILE expr KW_DO . block
    (27) block -> . LPAREN opt_nl stmt_list opt_nl RPAREN

    LPAREN          shift and go to state 104

    block                          shift and go to state 132

state 106

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER . COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 133


state 107

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER . COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 134


state 108

    (45) map_op -> MAP_SET LPAREN IDENTIFIER . COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 135


state 109

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER . COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 136


state 110

    (17) var_decl -> KW_INT IDENTIFIER OP_ASSIGN expr .

    NEWLINE         reduce using rule 17 (var_decl -> KW_INT IDENTIFIER OP_ASSIGN expr .)


state 111

    (18) var_decl -> KW_BOOLEAN IDENTIFIER OP_ASSIGN expr .

    NEWLINE         reduce using rule 18 (var_decl -> KW_BOOLEAN IDENTIFIER OP_ASSIGN expr .)


state 112

    (19) const_decl -> KW_CINT IDENTIFIER OP_ASSIGN expr .

    NEWLINE         reduce using rule 19 (const_decl -> KW_CINT IDENTIFIER OP_ASSIGN expr .)


state 113

    (20) const_decl -> KW_CBOOLEAN IDENTIFIER OP_ASSIGN expr .

    NEWLINE         reduce using rule 20 (const_decl -> KW_CBOOLEAN IDENTIFIER OP_ASSIGN expr .)


state 114

    (22) proc_decl -> KW_PROC IDENTIFIER param_list_opt block .

    NEWLINE         reduce using rule 22 (proc_decl -> KW_PROC IDENTIFIER param_list_opt block .)


state 115

    (52) arith_expr -> arith_expr + arith_expr .
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    +               reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    -               reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    TRUE            reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    FALSE           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_NOT          reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_GT           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_LT           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_EQ           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_STEP         reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_BACK         reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_RIGHT        reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_LEFT         reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_LOOK         reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    IDENTIFIER      reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    INT_LITERAL     reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    LPAREN          reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    KW_DO           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    NEWLINE         reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    COMMA           reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    RPAREN          reduce using rule 52 (arith_expr -> arith_expr + arith_expr .)
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96

  ! OP_INC          [ reduce using rule 52 (arith_expr -> arith_expr + arith_expr .) ]
  ! OP_DEC          [ reduce using rule 52 (arith_expr -> arith_expr + arith_expr .) ]
  ! +               [ shift and go to state 93 ]
  ! -               [ shift and go to state 94 ]


state 116

    (58) term -> IDENTIFIER .
    (37) proc_call -> IDENTIFIER . param_list_opt
    (23) param_list_opt -> . param_list
    (24) param_list_opt -> . empty
    (25) param_list -> . IDENTIFIER
    (26) param_list -> . param_list IDENTIFIER
    (68) empty -> .

  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for + resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for - resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_INC resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_DEC resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for TRUE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for FALSE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_NOT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_GT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_EQ resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_STEP resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_BACK resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_RIGHT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LEFT resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for OP_LOOK resolved using rule 58 (term -> IDENTIFIER .)
  ! shift/reduce conflict for IDENTIFIER resolved as shift
  ! reduce/reduce conflict for INT_LITERAL resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for LPAREN resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for KW_DO resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for NEWLINE resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for COMMA resolved using rule 58 (term -> IDENTIFIER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 58 (term -> IDENTIFIER .)
    +               reduce using rule 58 (term -> IDENTIFIER .)
    -               reduce using rule 58 (term -> IDENTIFIER .)
    OP_INC          reduce using rule 58 (term -> IDENTIFIER .)
    OP_DEC          reduce using rule 58 (term -> IDENTIFIER .)
    TRUE            reduce using rule 58 (term -> IDENTIFIER .)
    FALSE           reduce using rule 58 (term -> IDENTIFIER .)
    OP_NOT          reduce using rule 58 (term -> IDENTIFIER .)
    OP_GT           reduce using rule 58 (term -> IDENTIFIER .)
    OP_LT           reduce using rule 58 (term -> IDENTIFIER .)
    OP_EQ           reduce using rule 58 (term -> IDENTIFIER .)
    OP_STEP         reduce using rule 58 (term -> IDENTIFIER .)
    OP_BACK         reduce using rule 58 (term -> IDENTIFIER .)
    OP_RIGHT        reduce using rule 58 (term -> IDENTIFIER .)
    OP_LEFT         reduce using rule 58 (term -> IDENTIFIER .)
    OP_LOOK         reduce using rule 58 (term -> IDENTIFIER .)
    INT_LITERAL     reduce using rule 58 (term -> IDENTIFIER .)
    LPAREN          reduce using rule 58 (term -> IDENTIFIER .)
    KW_DO           reduce using rule 58 (term -> IDENTIFIER .)
    NEWLINE         reduce using rule 58 (term -> IDENTIFIER .)
    COMMA           reduce using rule 58 (term -> IDENTIFIER .)
    RPAREN          reduce using rule 58 (term -> IDENTIFIER .)
    IDENTIFIER      shift and go to state 51

  ! IDENTIFIER      [ reduce using rule 58 (term -> IDENTIFIER .) ]
  ! +               [ reduce using rule 68 (empty -> .) ]
  ! -               [ reduce using rule 68 (empty -> .) ]
  ! OP_INC          [ reduce using rule 68 (empty -> .) ]
  ! OP_DEC          [ reduce using rule 68 (empty -> .) ]
  ! TRUE            [ reduce using rule 68 (empty -> .) ]
  ! FALSE           [ reduce using rule 68 (empty -> .) ]
  ! OP_NOT          [ reduce using rule 68 (empty -> .) ]
  ! OP_GT           [ reduce using rule 68 (empty -> .) ]
  ! OP_LT           [ reduce using rule 68 (empty -> .) ]
  ! OP_EQ           [ reduce using rule 68 (empty -> .) ]
  ! OP_STEP         [ reduce using rule 68 (empty -> .) ]
  ! OP_BACK         [ reduce using rule 68 (empty -> .) ]
  ! OP_RIGHT        [ reduce using rule 68 (empty -> .) ]
  ! OP_LEFT         [ reduce using rule 68 (empty -> .) ]
  ! OP_LOOK         [ reduce using rule 68 (empty -> .) ]
  ! IDENTIFIER      [ reduce using rule 68 (empty -> .) ]
  ! INT_LITERAL     [ reduce using rule 68 (empty -> .) ]
  ! LPAREN          [ reduce using rule 68 (empty -> .) ]
  ! KW_DO           [ reduce using rule 68 (empty -> .) ]
  ! NEWLINE         [ reduce using rule 68 (empty -> .) ]
  ! COMMA           [ reduce using rule 68 (empty -> .) ]
  ! RPAREN          [ reduce using rule 68 (empty -> .) ]

    param_list_opt                 shift and go to state 53
    param_list                     shift and go to state 54
    empty                          shift and go to state 55

state 117

    (59) term -> proc_call .

    +               reduce using rule 59 (term -> proc_call .)
    -               reduce using rule 59 (term -> proc_call .)
    OP_INC          reduce using rule 59 (term -> proc_call .)
    OP_DEC          reduce using rule 59 (term -> proc_call .)
    TRUE            reduce using rule 59 (term -> proc_call .)
    FALSE           reduce using rule 59 (term -> proc_call .)
    OP_NOT          reduce using rule 59 (term -> proc_call .)
    OP_GT           reduce using rule 59 (term -> proc_call .)
    OP_LT           reduce using rule 59 (term -> proc_call .)
    OP_EQ           reduce using rule 59 (term -> proc_call .)
    OP_STEP         reduce using rule 59 (term -> proc_call .)
    OP_BACK         reduce using rule 59 (term -> proc_call .)
    OP_RIGHT        reduce using rule 59 (term -> proc_call .)
    OP_LEFT         reduce using rule 59 (term -> proc_call .)
    OP_LOOK         reduce using rule 59 (term -> proc_call .)
    IDENTIFIER      reduce using rule 59 (term -> proc_call .)
    INT_LITERAL     reduce using rule 59 (term -> proc_call .)
    LPAREN          reduce using rule 59 (term -> proc_call .)
    KW_DO           reduce using rule 59 (term -> proc_call .)
    NEWLINE         reduce using rule 59 (term -> proc_call .)
    COMMA           reduce using rule 59 (term -> proc_call .)
    RPAREN          reduce using rule 59 (term -> proc_call .)


state 118

    (60) term -> OP_LOOK .

    +               reduce using rule 60 (term -> OP_LOOK .)
    -               reduce using rule 60 (term -> OP_LOOK .)
    OP_INC          reduce using rule 60 (term -> OP_LOOK .)
    OP_DEC          reduce using rule 60 (term -> OP_LOOK .)
    TRUE            reduce using rule 60 (term -> OP_LOOK .)
    FALSE           reduce using rule 60 (term -> OP_LOOK .)
    OP_NOT          reduce using rule 60 (term -> OP_LOOK .)
    OP_GT           reduce using rule 60 (term -> OP_LOOK .)
    OP_LT           reduce using rule 60 (term -> OP_LOOK .)
    OP_EQ           reduce using rule 60 (term -> OP_LOOK .)
    OP_STEP         reduce using rule 60 (term -> OP_LOOK .)
    OP_BACK         reduce using rule 60 (term -> OP_LOOK .)
    OP_RIGHT        reduce using rule 60 (term -> OP_LOOK .)
    OP_LEFT         reduce using rule 60 (term -> OP_LOOK .)
    OP_LOOK         reduce using rule 60 (term -> OP_LOOK .)
    IDENTIFIER      reduce using rule 60 (term -> OP_LOOK .)
    INT_LITERAL     reduce using rule 60 (term -> OP_LOOK .)
    LPAREN          reduce using rule 60 (term -> OP_LOOK .)
    KW_DO           reduce using rule 60 (term -> OP_LOOK .)
    NEWLINE         reduce using rule 60 (term -> OP_LOOK .)
    COMMA           reduce using rule 60 (term -> OP_LOOK .)
    RPAREN          reduce using rule 60 (term -> OP_LOOK .)


state 119

    (53) arith_expr -> arith_expr - arith_expr .
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    +               reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    -               reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    TRUE            reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    FALSE           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_NOT          reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_GT           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_LT           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_EQ           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_STEP         reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_BACK         reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_RIGHT        reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_LEFT         reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_LOOK         reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    IDENTIFIER      reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    INT_LITERAL     reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    LPAREN          reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    KW_DO           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    NEWLINE         reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    COMMA           reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    RPAREN          reduce using rule 53 (arith_expr -> arith_expr - arith_expr .)
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96

  ! OP_INC          [ reduce using rule 53 (arith_expr -> arith_expr - arith_expr .) ]
  ! OP_DEC          [ reduce using rule 53 (arith_expr -> arith_expr - arith_expr .) ]
  ! +               [ shift and go to state 93 ]
  ! -               [ shift and go to state 94 ]


state 120

    (54) arith_expr -> arith_expr OP_INC arith_expr .
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    +               reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    -               reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_INC          reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_DEC          reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    TRUE            reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    FALSE           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_NOT          reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_GT           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_LT           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_EQ           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_STEP         reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_BACK         reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_RIGHT        reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_LEFT         reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    OP_LOOK         reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    IDENTIFIER      reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    INT_LITERAL     reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    LPAREN          reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    KW_DO           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    NEWLINE         reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    COMMA           reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)
    RPAREN          reduce using rule 54 (arith_expr -> arith_expr OP_INC arith_expr .)

  ! +               [ shift and go to state 93 ]
  ! -               [ shift and go to state 94 ]
  ! OP_INC          [ shift and go to state 95 ]
  ! OP_DEC          [ shift and go to state 96 ]


state 121

    (55) arith_expr -> arith_expr OP_DEC arith_expr .
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    +               reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    -               reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_INC          reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_DEC          reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    TRUE            reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    FALSE           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_NOT          reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_GT           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_LT           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_EQ           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_STEP         reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_BACK         reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_RIGHT        reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_LEFT         reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    OP_LOOK         reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    IDENTIFIER      reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    INT_LITERAL     reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    LPAREN          reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    KW_DO           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    NEWLINE         reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    COMMA           reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)
    RPAREN          reduce using rule 55 (arith_expr -> arith_expr OP_DEC arith_expr .)

  ! +               [ shift and go to state 93 ]
  ! -               [ shift and go to state 94 ]
  ! OP_INC          [ shift and go to state 95 ]
  ! OP_DEC          [ shift and go to state 96 ]


state 122

    (67) logic_expr -> logic_expr OP_OR logic_expr .
    (67) logic_expr -> logic_expr . OP_OR logic_expr

    OP_OR           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    TRUE            reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    FALSE           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_NOT          reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_GT           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_LT           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_EQ           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_STEP         reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_BACK         reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_RIGHT        reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_LEFT         reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    OP_LOOK         reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    IDENTIFIER      reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    INT_LITERAL     reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    LPAREN          reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    KW_DO           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    NEWLINE         reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    RPAREN          reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)
    COMMA           reduce using rule 67 (logic_expr -> logic_expr OP_OR logic_expr .)

  ! OP_OR           [ shift and go to state 97 ]


state 123

    (63) logic_expr -> OP_NOT LPAREN logic_expr . RPAREN
    (67) logic_expr -> logic_expr . OP_OR logic_expr

    RPAREN          shift and go to state 137
    OP_OR           shift and go to state 97


state 124

    (64) logic_expr -> OP_GT LPAREN expr . COMMA expr RPAREN

    COMMA           shift and go to state 138


state 125

    (65) logic_expr -> OP_LT LPAREN expr . COMMA expr RPAREN

    COMMA           shift and go to state 139


state 126

    (66) logic_expr -> OP_EQ LPAREN expr . COMMA expr RPAREN

    COMMA           shift and go to state 140


state 127

    (33) if_stmt -> KW_IF expr block else_opt .

    NEWLINE         reduce using rule 33 (if_stmt -> KW_IF expr block else_opt .)


state 128

    (34) else_opt -> KW_ELSE . block
    (27) block -> . LPAREN opt_nl stmt_list opt_nl RPAREN

    LPAREN          shift and go to state 104

    block                          shift and go to state 141

state 129

    (35) else_opt -> empty .

    NEWLINE         reduce using rule 35 (else_opt -> empty .)


state 130

    (27) block -> LPAREN opt_nl . stmt_list opt_nl RPAREN
    (28) opt_nl -> opt_nl . NEWLINE
    (2) stmt_list -> .
    (3) stmt_list -> . stmt_list stmt

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 143
    KW_INT          reduce using rule 2 (stmt_list -> .)
    KW_BOOLEAN      reduce using rule 2 (stmt_list -> .)
    KW_CINT         reduce using rule 2 (stmt_list -> .)
    KW_CBOOLEAN     reduce using rule 2 (stmt_list -> .)
    KW_MAP          reduce using rule 2 (stmt_list -> .)
    KW_PROC         reduce using rule 2 (stmt_list -> .)
    IDENTIFIER      reduce using rule 2 (stmt_list -> .)
    OP_INC          reduce using rule 2 (stmt_list -> .)
    OP_DEC          reduce using rule 2 (stmt_list -> .)
    KW_IF           reduce using rule 2 (stmt_list -> .)
    KW_WHILE        reduce using rule 2 (stmt_list -> .)
    OP_STEP         reduce using rule 2 (stmt_list -> .)
    OP_BACK         reduce using rule 2 (stmt_list -> .)
    OP_RIGHT        reduce using rule 2 (stmt_list -> .)
    OP_LEFT         reduce using rule 2 (stmt_list -> .)
    OP_LOOK         reduce using rule 2 (stmt_list -> .)
    MAP_BAR         reduce using rule 2 (stmt_list -> .)
    MAP_EMP         reduce using rule 2 (stmt_list -> .)
    MAP_SET         reduce using rule 2 (stmt_list -> .)
    MAP_CLR         reduce using rule 2 (stmt_list -> .)
    KW_PRINT        reduce using rule 2 (stmt_list -> .)
    RPAREN          reduce using rule 2 (stmt_list -> .)

  ! NEWLINE         [ reduce using rule 2 (stmt_list -> .) ]

    stmt_list                      shift and go to state 142

state 131

    (29) opt_nl -> empty .

    NEWLINE         reduce using rule 29 (opt_nl -> empty .)
    KW_INT          reduce using rule 29 (opt_nl -> empty .)
    KW_BOOLEAN      reduce using rule 29 (opt_nl -> empty .)
    KW_CINT         reduce using rule 29 (opt_nl -> empty .)
    KW_CBOOLEAN     reduce using rule 29 (opt_nl -> empty .)
    KW_MAP          reduce using rule 29 (opt_nl -> empty .)
    KW_PROC         reduce using rule 29 (opt_nl -> empty .)
    IDENTIFIER      reduce using rule 29 (opt_nl -> empty .)
    OP_INC          reduce using rule 29 (opt_nl -> empty .)
    OP_DEC          reduce using rule 29 (opt_nl -> empty .)
    KW_IF           reduce using rule 29 (opt_nl -> empty .)
    KW_WHILE        reduce using rule 29 (opt_nl -> empty .)
    OP_STEP         reduce using rule 29 (opt_nl -> empty .)
    OP_BACK         reduce using rule 29 (opt_nl -> empty .)
    OP_RIGHT        reduce using rule 29 (opt_nl -> empty .)
    OP_LEFT         reduce using rule 29 (opt_nl -> empty .)
    OP_LOOK         reduce using rule 29 (opt_nl -> empty .)
    MAP_BAR         reduce using rule 29 (opt_nl -> empty .)
    MAP_EMP         reduce using rule 29 (opt_nl -> empty .)
    MAP_SET         reduce using rule 29 (opt_nl -> empty .)
    MAP_CLR         reduce using rule 29 (opt_nl -> empty .)
    KW_PRINT        reduce using rule 29 (opt_nl -> empty .)
    RPAREN          reduce using rule 29 (opt_nl -> empty .)


state 132

    (36) while_stmt -> KW_WHILE expr KW_DO block .

    NEWLINE         reduce using rule 36 (while_stmt -> KW_WHILE expr KW_DO block .)


state 133

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA . IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 144


state 134

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA . IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 145


state 135

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA . IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 146


state 136

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA . IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN

    IDENTIFIER      shift and go to state 147


state 137

    (63) logic_expr -> OP_NOT LPAREN logic_expr RPAREN .

    OP_OR           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    TRUE            reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    FALSE           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_NOT          reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_GT           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_LT           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_EQ           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_STEP         reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_BACK         reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_RIGHT        reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_LEFT         reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    OP_LOOK         reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    IDENTIFIER      reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    INT_LITERAL     reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    LPAREN          reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    KW_DO           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    NEWLINE         reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    RPAREN          reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)
    COMMA           reduce using rule 63 (logic_expr -> OP_NOT LPAREN logic_expr RPAREN .)


state 138

    (64) logic_expr -> OP_GT LPAREN expr COMMA . expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 148
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 139

    (65) logic_expr -> OP_LT LPAREN expr COMMA . expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 149
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 140

    (66) logic_expr -> OP_EQ LPAREN expr COMMA . expr RPAREN
    (48) expr -> . arith_expr
    (49) expr -> . logic_expr
    (50) expr -> . robot_op
    (51) expr -> . proc_call
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (61) logic_expr -> . TRUE
    (62) logic_expr -> . FALSE
    (63) logic_expr -> . OP_NOT LPAREN logic_expr RPAREN
    (64) logic_expr -> . OP_GT LPAREN expr COMMA expr RPAREN
    (65) logic_expr -> . OP_LT LPAREN expr COMMA expr RPAREN
    (66) logic_expr -> . OP_EQ LPAREN expr COMMA expr RPAREN
    (67) logic_expr -> . logic_expr OP_OR logic_expr
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK

    TRUE            shift and go to state 67
    FALSE           shift and go to state 68
    OP_NOT          shift and go to state 69
    OP_GT           shift and go to state 70
    OP_LT           shift and go to state 71
    OP_EQ           shift and go to state 72
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 74
    IDENTIFIER      shift and go to state 73
    INT_LITERAL     shift and go to state 75

    expr                           shift and go to state 150
    arith_expr                     shift and go to state 62
    logic_expr                     shift and go to state 63
    robot_op                       shift and go to state 64
    proc_call                      shift and go to state 65
    term                           shift and go to state 66

state 141

    (34) else_opt -> KW_ELSE block .

    NEWLINE         reduce using rule 34 (else_opt -> KW_ELSE block .)


state 142

    (27) block -> LPAREN opt_nl stmt_list . opt_nl RPAREN
    (3) stmt_list -> stmt_list . stmt
    (28) opt_nl -> . opt_nl NEWLINE
    (29) opt_nl -> . empty
    (4) stmt -> . var_decl NEWLINE
    (5) stmt -> . const_decl NEWLINE
    (6) stmt -> . map_decl NEWLINE
    (7) stmt -> . proc_decl NEWLINE
    (8) stmt -> . assignment NEWLINE
    (9) stmt -> . incdec NEWLINE
    (10) stmt -> . if_stmt NEWLINE
    (11) stmt -> . while_stmt NEWLINE
    (12) stmt -> . proc_call NEWLINE
    (13) stmt -> . robot_op NEWLINE
    (14) stmt -> . map_op NEWLINE
    (15) stmt -> . print_stmt NEWLINE
    (16) stmt -> . NEWLINE
    (68) empty -> .
    (17) var_decl -> . KW_INT IDENTIFIER OP_ASSIGN expr
    (18) var_decl -> . KW_BOOLEAN IDENTIFIER OP_ASSIGN expr
    (19) const_decl -> . KW_CINT IDENTIFIER OP_ASSIGN expr
    (20) const_decl -> . KW_CBOOLEAN IDENTIFIER OP_ASSIGN expr
    (21) map_decl -> . KW_MAP IDENTIFIER
    (22) proc_decl -> . KW_PROC IDENTIFIER param_list_opt block
    (30) assignment -> . IDENTIFIER OP_ASSIGN expr
    (31) incdec -> . OP_INC expr expr
    (32) incdec -> . OP_DEC expr expr
    (33) if_stmt -> . KW_IF expr block else_opt
    (36) while_stmt -> . KW_WHILE expr KW_DO block
    (37) proc_call -> . IDENTIFIER param_list_opt
    (38) robot_op -> . OP_STEP IDENTIFIER
    (39) robot_op -> . OP_BACK
    (40) robot_op -> . OP_RIGHT
    (41) robot_op -> . OP_LEFT
    (42) robot_op -> . OP_LOOK
    (43) map_op -> . MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (44) map_op -> . MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (45) map_op -> . MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (46) map_op -> . MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN
    (47) print_stmt -> . KW_PRINT expr

  ! shift/reduce conflict for NEWLINE resolved as shift
    NEWLINE         shift and go to state 5
    RPAREN          reduce using rule 68 (empty -> .)
    KW_INT          shift and go to state 17
    KW_BOOLEAN      shift and go to state 19
    KW_CINT         shift and go to state 20
    KW_CBOOLEAN     shift and go to state 21
    KW_MAP          shift and go to state 22
    KW_PROC         shift and go to state 23
    IDENTIFIER      shift and go to state 18
    OP_INC          shift and go to state 24
    OP_DEC          shift and go to state 25
    KW_IF           shift and go to state 26
    KW_WHILE        shift and go to state 27
    OP_STEP         shift and go to state 28
    OP_BACK         shift and go to state 29
    OP_RIGHT        shift and go to state 30
    OP_LEFT         shift and go to state 31
    OP_LOOK         shift and go to state 32
    MAP_BAR         shift and go to state 33
    MAP_EMP         shift and go to state 34
    MAP_SET         shift and go to state 35
    MAP_CLR         shift and go to state 36
    KW_PRINT        shift and go to state 37

  ! NEWLINE         [ reduce using rule 68 (empty -> .) ]

    opt_nl                         shift and go to state 151
    stmt                           shift and go to state 3
    empty                          shift and go to state 131
    var_decl                       shift and go to state 4
    const_decl                     shift and go to state 6
    map_decl                       shift and go to state 7
    proc_decl                      shift and go to state 8
    assignment                     shift and go to state 9
    incdec                         shift and go to state 10
    if_stmt                        shift and go to state 11
    while_stmt                     shift and go to state 12
    proc_call                      shift and go to state 13
    robot_op                       shift and go to state 14
    map_op                         shift and go to state 15
    print_stmt                     shift and go to state 16

state 143

    (28) opt_nl -> opt_nl NEWLINE .

    NEWLINE         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_INT          reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_BOOLEAN      reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_CINT         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_CBOOLEAN     reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_MAP          reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_PROC         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    IDENTIFIER      reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_INC          reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_DEC          reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_IF           reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_WHILE        reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_STEP         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_BACK         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_RIGHT        reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_LEFT         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    OP_LOOK         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    MAP_BAR         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    MAP_EMP         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    MAP_SET         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    MAP_CLR         reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    KW_PRINT        reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)
    RPAREN          reduce using rule 28 (opt_nl -> opt_nl NEWLINE .)


state 144

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER . COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 152


state 145

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER . COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 153


state 146

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER . COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 154


state 147

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER . COMMA arith_expr COMMA arith_expr RPAREN

    COMMA           shift and go to state 155


state 148

    (64) logic_expr -> OP_GT LPAREN expr COMMA expr . RPAREN

    RPAREN          shift and go to state 156


state 149

    (65) logic_expr -> OP_LT LPAREN expr COMMA expr . RPAREN

    RPAREN          shift and go to state 157


state 150

    (66) logic_expr -> OP_EQ LPAREN expr COMMA expr . RPAREN

    RPAREN          shift and go to state 158


state 151

    (27) block -> LPAREN opt_nl stmt_list opt_nl . RPAREN
    (28) opt_nl -> opt_nl . NEWLINE

    RPAREN          shift and go to state 159
    NEWLINE         shift and go to state 143


state 152

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA . arith_expr COMMA arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 160
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 153

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA . arith_expr COMMA arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 161
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 154

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA . arith_expr COMMA arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 162
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 155

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA . arith_expr COMMA arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 163
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 156

    (64) logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .

    OP_OR           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    TRUE            reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    FALSE           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_NOT          reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_GT           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_LT           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_EQ           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_STEP         reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_BACK         reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_RIGHT        reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_LEFT         reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    OP_LOOK         reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    IDENTIFIER      reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    INT_LITERAL     reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    LPAREN          reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    KW_DO           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    NEWLINE         reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    RPAREN          reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)
    COMMA           reduce using rule 64 (logic_expr -> OP_GT LPAREN expr COMMA expr RPAREN .)


state 157

    (65) logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .

    OP_OR           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    TRUE            reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    FALSE           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_NOT          reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_GT           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_LT           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_EQ           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_STEP         reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_BACK         reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_RIGHT        reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_LEFT         reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    OP_LOOK         reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    IDENTIFIER      reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    INT_LITERAL     reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    LPAREN          reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    KW_DO           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    NEWLINE         reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    RPAREN          reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)
    COMMA           reduce using rule 65 (logic_expr -> OP_LT LPAREN expr COMMA expr RPAREN .)


state 158

    (66) logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .

    OP_OR           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    TRUE            reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    FALSE           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_NOT          reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_GT           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_LT           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_EQ           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_STEP         reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_BACK         reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_RIGHT        reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_LEFT         reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    OP_LOOK         reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    IDENTIFIER      reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    INT_LITERAL     reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    LPAREN          reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    KW_DO           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    NEWLINE         reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    RPAREN          reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)
    COMMA           reduce using rule 66 (logic_expr -> OP_EQ LPAREN expr COMMA expr RPAREN .)


state 159

    (27) block -> LPAREN opt_nl stmt_list opt_nl RPAREN .

    KW_ELSE         reduce using rule 27 (block -> LPAREN opt_nl stmt_list opt_nl RPAREN .)
    NEWLINE         reduce using rule 27 (block -> LPAREN opt_nl stmt_list opt_nl RPAREN .)


state 160

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr . COMMA arith_expr RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    COMMA           shift and go to state 164
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 161

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr . COMMA arith_expr RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    COMMA           shift and go to state 165
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 162

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr . COMMA arith_expr RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    COMMA           shift and go to state 166
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 163

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr . COMMA arith_expr RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    COMMA           shift and go to state 167
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 164

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA . arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 168
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 165

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA . arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 169
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 166

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA . arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 170
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 167

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA . arith_expr RPAREN
    (52) arith_expr -> . arith_expr + arith_expr
    (53) arith_expr -> . arith_expr - arith_expr
    (54) arith_expr -> . arith_expr OP_INC arith_expr
    (55) arith_expr -> . arith_expr OP_DEC arith_expr
    (56) arith_expr -> . term
    (57) term -> . INT_LITERAL
    (58) term -> . IDENTIFIER
    (59) term -> . proc_call
    (60) term -> . OP_LOOK
    (37) proc_call -> . IDENTIFIER param_list_opt

    INT_LITERAL     shift and go to state 75
    IDENTIFIER      shift and go to state 116
    OP_LOOK         shift and go to state 118

    arith_expr                     shift and go to state 171
    term                           shift and go to state 66
    proc_call                      shift and go to state 117

state 168

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr . RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    RPAREN          shift and go to state 172
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 169

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr . RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    RPAREN          shift and go to state 173
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 170

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr . RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    RPAREN          shift and go to state 174
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 171

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr . RPAREN
    (52) arith_expr -> arith_expr . + arith_expr
    (53) arith_expr -> arith_expr . - arith_expr
    (54) arith_expr -> arith_expr . OP_INC arith_expr
    (55) arith_expr -> arith_expr . OP_DEC arith_expr

    RPAREN          shift and go to state 175
    +               shift and go to state 93
    -               shift and go to state 94
    OP_INC          shift and go to state 95
    OP_DEC          shift and go to state 96


state 172

    (43) map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .

    NEWLINE         reduce using rule 43 (map_op -> MAP_BAR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .)


state 173

    (44) map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .

    NEWLINE         reduce using rule 44 (map_op -> MAP_EMP LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .)


state 174

    (45) map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .

    NEWLINE         reduce using rule 45 (map_op -> MAP_SET LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .)


state 175

    (46) map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .

    NEWLINE         reduce using rule 46 (map_op -> MAP_CLR LPAREN IDENTIFIER COMMA IDENTIFIER COMMA arith_expr COMMA arith_expr RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for IDENTIFIER in state 54 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 73 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 73 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 116 resolved as shift
WARNING: shift/reduce conflict for IDENTIFIER in state 116 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 130 resolved as shift
WARNING: shift/reduce conflict for NEWLINE in state 142 resolved as shift
WARNING: reduce/reduce conflict in state 65 resolved using rule (expr -> proc_call)
WARNING: rejected rule (term -> proc_call) in state 65
WARNING: reduce/reduce conflict in state 73 resolved using rule (term -> IDENTIFIER)
WARNING: rejected rule (empty -> <empty>) in state 73
WARNING: reduce/reduce conflict in state 74 resolved using rule (robot_op -> OP_LOOK)
WARNING: rejected rule (term -> OP_LOOK) in state 74
WARNING: reduce/reduce conflict in state 116 resolved using rule (term -> IDENTIFIER)
WARNING: rejected rule (empty -> <empty>) in state 116
